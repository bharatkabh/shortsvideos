<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Smart Box Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none; /* Disables pinch-zoom, double-tap-zoom, etc. */
            overscroll-behavior: none;
        }
        /* Custom styles for the stroke width slider */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #22d3ee;
            cursor: pointer;
            border-radius: 50%;
            border: 4px solid #1e293b;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #22d3ee;
            cursor: pointer;
            border-radius: 50%;
            border: 4px solid #1e293b;
        }
    </style>
</head>
<body class="bg-gray-900 flex items-center justify-center h-screen overflow-hidden">

    <!-- Main container to enforce the 9:16 aspect ratio -->
    <div class="relative w-full max-w-[calc(100vh*9/16)] h-full max-h-screen shadow-2xl bg-slate-800" id="main-container">
        <canvas id="editor-canvas" class="w-full h-full"></canvas>
    </div>

    <!-- Floating Controls Panel - Hidden by default -->
    <div id="controls-panel" class="absolute top-4 right-4 bg-slate-800 bg-opacity-80 backdrop-blur-md text-white p-6 rounded-2xl shadow-lg w-80 max-w-[90vw] transition-transform duration-300 translate-x-[120%] opacity-0">
        <div class="flex justify-between items-center mb-6 border-b border-slate-600 pb-3">
            <h2 class="text-xl font-bold">Box Properties</h2>
            <button id="delete-btn" class="p-2 rounded-full bg-red-600 hover:bg-red-700 text-white transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>
            </button>
        </div>
        
        <div class="space-y-5">
            <div>
                <label for="fill-color-picker" class="block mb-2 font-medium text-slate-300">Fill Color</label>
                <input type="color" id="fill-color-picker" value="#334155" class="w-full h-12 p-1 bg-slate-700 rounded-lg cursor-pointer border-2 border-slate-600">
            </div>
            <div>
                <label for="stroke-color-picker" class="block mb-2 font-medium text-slate-300">Stroke Color</label>
                <input type="color" id="stroke-color-picker" value="#22d3ee" class="w-full h-12 p-1 bg-slate-700 rounded-lg cursor-pointer border-2 border-slate-600">
            </div>
            <div>
                <label for="stroke-width-slider" class="block mb-2 font-medium text-slate-300">Stroke Width</label>
                <input type="range" id="stroke-width-slider" min="0" max="30" step="1" value="4" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
            </div>
        </div>
    </div>

<script>
    // --- SETUP ---
    const canvas = document.getElementById('editor-canvas');
    const ctx = canvas.getContext('2d');
    const mainContainer = document.getElementById('main-container');

    const controlsPanel = document.getElementById('controls-panel');
    const fillColorPicker = document.getElementById('fill-color-picker');
    const strokeColorPicker = document.getElementById('stroke-color-picker');
    const strokeWidthSlider = document.getElementById('stroke-width-slider');
    const deleteBtn = document.getElementById('delete-btn');

    let boxes = [];
    let selectedBox = null;
    let action = { type: null, handle: null, startX: 0, startY: 0 };
    let lastTap = 0;
    const snapThreshold = 10;

    // --- UTILITY & GEOMETRY FUNCTIONS ---

    function getTouchPos(e) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches ? e.touches[0] : e;
        return {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top
        };
    }

    function isPointInBox(x, y, box) {
        return x > box.x && x < box.x + box.width && y > box.y && y < box.y + box.height;
    }
    
    function getResizeHandle(x, y, box) {
        const handleSize = 15;
        const handles = {
            'top-left': { x: box.x, y: box.y },
            'top-right': { x: box.x + box.width, y: box.y },
            'bottom-left': { x: box.x, y: box.y + box.height },
            'bottom-right': { x: box.x + box.width, y: box.y + box.height }
        };

        for (const [name, pos] of Object.entries(handles)) {
            if (Math.abs(x - pos.x) < handleSize && Math.abs(y - pos.y) < handleSize) {
                return name;
            }
        }
        return null;
    }

    // New function to check for overlaps between any two boxes
    function isOverlapping(box1, box2) {
        if (!box1 || !box2 || box1.id === box2.id) return false;
        return !(box1.x + box1.width <= box2.x || 
                   box1.x >= box2.x + box2.width || 
                   box1.y + box1.height <= box2.y || 
                   box1.y >= box2.y + box2.height);
    }


    // --- DRAWING LOGIC ---

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        boxes.forEach(box => {
            ctx.fillStyle = box.fillColor;
            ctx.strokeStyle = box.strokeColor;
            ctx.lineWidth = box.strokeWidth;
            
            ctx.fillRect(box.x, box.y, box.width, box.height);
            if (box.strokeWidth > 0) {
                ctx.strokeRect(box.x, box.y, box.width, box.height);
            }
        });

        if (selectedBox) {
            drawSelection(selectedBox);
        }
    }

    function drawSelection(box) {
        ctx.strokeStyle = '#22d3ee';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 3]);
        ctx.strokeRect(box.x - 4, box.y - 4, box.width + 8, box.height + 8);
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#22d3ee';
        const handleSize = 10;
        const handles = {
            'top-left': { x: box.x, y: box.y },
            'top-right': { x: box.x + box.width, y: box.y },
            'bottom-left': { x: box.x, y: box.y + box.height },
            'bottom-right': { x: box.x + box.width, y: box.y + box.height }
        };
        for (const pos of Object.values(handles)) {
            ctx.fillRect(pos.x - handleSize/2, pos.y - handleSize/2, handleSize, handleSize);
        }
    }

    // --- BOX MANIPULATION ---

    function createBox(x, y) {
        const newBox = {
            id: Date.now(),
            x: x - 50,
            y: y - 50,
            width: 100,
            height: 100,
            fillColor: '#334155',
            strokeColor: '#22d3ee',
            strokeWidth: 4
        };
        boxes.push(newBox);
        return newBox;
    }
    
    function deleteSelectedBox() {
        if (!selectedBox) return;
        boxes = boxes.filter(b => b.id !== selectedBox.id);
        setSelectedBox(null);
    }

    function setSelectedBox(box) {
        selectedBox = box;
        if (box) {
            controlsPanel.classList.remove('translate-x-[120%]', 'opacity-0');
            fillColorPicker.value = box.fillColor;
            strokeColorPicker.value = box.strokeColor;
            strokeWidthSlider.value = box.strokeWidth;
        } else {
            controlsPanel.classList.add('translate-x-[120%]', 'opacity-0');
        }
    }

    // --- SNAPPING LOGIC ---

    function performSnapping(movingBox) {
        // This function remains the same, used for edge alignment
        let snapX = null;
        let snapY = null;
        
        const otherBoxes = boxes.filter(b => b.id !== movingBox.id);
        if (otherBoxes.length === 0) return;

        const boxEdges = [
            { pos: movingBox.x, edge: 'left' },
            { pos: movingBox.x + movingBox.width, edge: 'right' }
        ];
        const otherEdgesX = otherBoxes.flatMap(b => [ { pos: b.x }, { pos: b.x + b.width } ]);

        for(const edge of boxEdges) {
            for(const otherEdge of otherEdgesX) {
                if (Math.abs(edge.pos - otherEdge.pos) < snapThreshold) {
                    snapX = edge.edge === 'left' ? otherEdge.pos : otherEdge.pos - movingBox.width;
                    break;
                }
            }
            if (snapX !== null) break;
        }

        const boxEdgesY = [
            { pos: movingBox.y, edge: 'top' },
            { pos: movingBox.y + movingBox.height, edge: 'bottom' }
        ];
        const otherEdgesY = otherBoxes.flatMap(b => [ { pos: b.y }, { pos: b.y + b.height } ]);

        for(const edge of boxEdgesY) {
            for(const otherEdge of otherEdgesY) {
                if (Math.abs(edge.pos - otherEdge.pos) < snapThreshold) {
                    snapY = edge.edge === 'top' ? otherEdge.pos : otherEdge.pos - movingBox.height;
                    break;
                }
            }
            if (snapY !== null) break;
        }

        if (snapX !== null) movingBox.x = snapX;
        if (snapY !== null) movingBox.y = snapY;
    }

    // --- EVENT HANDLERS ---
    
    function handleStart(e) {
        e.preventDefault();
        const pos = getTouchPos(e);
        action.startX = pos.x;
        action.startY = pos.y;
        
        let boxToSelect = null;
        let handle = null;
        
        if (selectedBox) {
            handle = getResizeHandle(pos.x, pos.y, selectedBox);
        }

        if (handle) {
            action.type = 'resize';
            action.handle = handle;
        } else {
            boxToSelect = boxes.slice().reverse().find(box => isPointInBox(pos.x, pos.y, box));
            if (boxToSelect) {
                action.type = 'drag';
                setSelectedBox(boxToSelect);
            } else {
                setSelectedBox(null);
                action.type = 'select'; // Potential new box creation on end
            }
        }
    }

    function handleMove(e) {
        if (!action.type || !selectedBox) return; // Only proceed if an action is happening on a selected box
        e.preventDefault();
        
        const pos = getTouchPos(e);
        const dx = pos.x - action.startX;
        const dy = pos.y - action.startY;
        
        // Store the state before making changes
        const lastValidState = { x: selectedBox.x, y: selectedBox.y, width: selectedBox.width, height: selectedBox.height };

        if (action.type === 'drag') {
            selectedBox.x += dx;
            selectedBox.y += dy;
            performSnapping(selectedBox);
        } else if (action.type === 'resize') {
            // FIX: Resize logic now correctly modifies the current box state
            if (action.handle.includes('left')) {
                selectedBox.x += dx;
                selectedBox.width -= dx;
            }
            if (action.handle.includes('right')) {
                selectedBox.width += dx;
            }
            if (action.handle.includes('top')) {
                selectedBox.y += dy;
                selectedBox.height -= dy;
            }
            if (action.handle.includes('bottom')) {
                selectedBox.height += dy;
            }
            // Prevent inverted boxes
            if (selectedBox.width < 20) {
                 selectedBox.width = 20;
                 if(action.handle.includes('left')) selectedBox.x = lastValidState.x + lastValidState.width - 20;
            }
            if (selectedBox.height < 20) {
                selectedBox.height = 20;
                if(action.handle.includes('top')) selectedBox.y = lastValidState.y + lastValidState.height - 20;
            }
        }

        // --- NEW: Collision detection ---
        let collision = false;
        for (const otherBox of boxes) {
            if (isOverlapping(selectedBox, otherBox)) {
                collision = true;
                break;
            }
        }

        if (collision) {
            // If the new state causes an overlap, revert to the last valid state
            selectedBox.x = lastValidState.x;
            selectedBox.y = lastValidState.y;
            selectedBox.width = lastValidState.width;
            selectedBox.height = lastValidState.height;
        } else {
            // Only update the starting point for the next move if the current move was valid
            action.startX = pos.x;
            action.startY = pos.y;
        }
    }

    function handleEnd(e) {
        const pos = getTouchPos(e.changedTouches ? e.changedTouches[0] : e);
        const dx = pos.x - action.startX;
        const dy = pos.y - action.startY;
        
        // If it was a tap on an empty space, create a box
        if (action.type === 'select' && Math.abs(dx) < 5 && Math.abs(dy) < 5) {
             const currentTime = new Date().getTime();
             if (currentTime - lastTap > 200) { // Simple double tap prevention
                const newBox = createBox(pos.x, pos.y);
                setSelectedBox(newBox);
             }
             lastTap = currentTime;
        }
        
        action.type = null;
    }

    function setupEventListeners() {
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('touchmove', handleMove, { passive: false });
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', () => { action.type = null; });

        fillColorPicker.addEventListener('input', (e) => { if (selectedBox) selectedBox.fillColor = e.target.value; });
        strokeColorPicker.addEventListener('input', (e) => { if (selectedBox) selectedBox.strokeColor = e.target.value; });
        strokeWidthSlider.addEventListener('input', (e) => { if (selectedBox) selectedBox.strokeWidth = parseInt(e.target.value); });
        deleteBtn.addEventListener('click', deleteSelectedBox);
    }
    
    // --- INITIALIZATION ---
    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = mainContainer.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        // No longer scaling context, will draw in logical pixels.
        // This simplifies coordinate calculations significantly.
    }

    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        setupEventListeners();
        
        function animate() {
            draw();
            requestAnimationFrame(animate);
        }
        animate();
    }

    init();
</script>
</body>
</html>

